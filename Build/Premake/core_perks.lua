cp = {}

local output_prefix = "[core_perks] "
local project_configurations = { "debug", "dev", "profile", "release" }
local precompiled_filename = "precompiled"

function cp.print(msg)
	print(output_prefix..msg)
end

function cp.error(msg)
	error(output_prefix..msg)
end

-- Load extern modules
local extern_module_files = os.matchfiles("extern/*.lua")
for _, file in ipairs(extern_module_files) do
    local module_name = path.getbasename(file)
    cp[module_name] = dofile(file)
end

function cp.add_dependency_define(module)
	--defines("CP_"..module.define_suffix.."_DEPENDENCY")
end

function cp.configure(params)
	cp.root_path = params.root_path or path.getabsolute("..")
	cp.extern_path = path.join(cp.root_path, "extern")
	cp.source_path = path.join(cp.root_path, "source")
	cp.build_path = path.join(cp.root_path, "build")
	cp.projects_path = path.join(cp.build_path, "projects")
	cp.obj_path = path.join(cp.build_path, "obj")
	cp.target_path = path.join(cp.build_path, "bin/$(Configuration)")
	cp.workspaces_path = path.join(cp.build_path, "workspaces")
end

function cp.project(name)
	project(name)
	location(cp.projects_path)
	architecture "x64"
	kind "StaticLib"
	objdir(cp.obj_path)
	targetdir("$(SolutionDir)$(Platform)/$(Configuration)")
	libdirs { "$(OutDir)" }
	includedirs("..")
	includedirs(cp.extern_path)

	debugdir "$(OutDir)"
	configurations(project_configurations)

	filter{"configurations:debug"}
		defines {"CP_DEBUG", "CP_DEBUG_OR_DEV"}
	filter{"configurations:dev"}
		defines {"CP_DEV", "CP_DEBUG_OR_DEV"}
	filter{"configurations:profile"}
		defines {"CP_PROFILE"}
	filter{"configurations:release"}
		defines {"CP_RELEASE"}
	filter {}
end

function cp.cpp_project(name)
	cp.project(name)
	rtti "Off"
	language "C++"
	exceptionhandling "Off"
	vectorextensions "AVX"
	symbols "On"
	cppdialect "C++20"
	fatalwarnings { "All"}
	flags { "MultiProcessorCompile" }
	files { "**.cpp", "**.h", "**.hpp", "**.inl", "**.natvis", "**.lua" }

	if os.isfile(precompiled_filename..".h") then
		pchheader(precompiled_filename..".h")
		filter "action:vs*"
			pchsource(precompiled_filename..".cpp")
		filter {}
	end

	filter { "action:vs*" }
		files { "*.natvis"}
		defines { "_HAS_EXCEPTIONS=0" }
		buildoptions {"/Zc:preprocessor"} -- Required for C++20's __VA_OPT__() for some reason
		--flags { "StaticRuntime" }
		--linkoptions { "/ENTRY:mainCRTStartup" } -- TODO: Not working with DLL, should avoid that case somehow.
		linkoptions {"/ignore:4221"} -- warns when .cpp are empty depending on the order of obj linking.
		
	filter { "configurations:release" }
		optimize "On"
		omitframepointer "On"
	filter {}
end

function cp.shader_project(name, target_env)
	cp.project("shaders")
	kind "Utility"
	files { "**.vert", "**.frag", "**.comp", "**.tesc", "**.tese", "**.geom", "**.glsl", "**.h",
		"**.rgen", "**.rint", "**.rahit", "**.rchit", "**.rmiss", "**.rcall" }
	local shader_filter = 'files:**.vert or **.frag or **.comp or **.tesc or **.tese or **.geom or **.rgen or **.rint or **.rahit or **.rchit or **.rmiss or **.rcall'
	local shader_out_path = "$(OutDir)/"..name.."/%{file.name}.spv"

	filter {shader_filter}
		buildmessage 'Compiling %{file.relpath}'
		buildoutputs { shader_out_path }
	filter {shader_filter, "configurations:debug or dev"}
		buildcommands { '$(GLSLANG)/glslangValidator.exe -V -gVS --target-env '..target_env..' -d -o "'.. shader_out_path ..'" %{file.relpath}' }
		--buildcommands { '$(VULKAN_SDK)/bin/glslc.exe -g --target-spv='..target_env..' -o "'.. shader_out_path ..'" %{file.relpath}' }
	filter {shader_filter, "configurations:profile or release"}
		buildcommands { '$(GLSLANG)/glslangValidator.exe -V -g0 --target-env '..target_env..' -d -o "'.. shader_out_path ..'" %{file.relpath}' }
		--buildcommands { '$(VULKAN_SDK)/bin/glslc.exe -O --target-spv='..target_env..' -o "'.. shader_out_path ..'" %{file.relpath}' }
	filter {}
end

function cp.workspace(name)
	workspace(name)
	configurations(project_configurations)
	location "workspaces"
	includedirs(path.join(cp.extern_path, "core_perks"))
end

function cp.add_dependency(project_name)
	filter "kind:WindowedApp"
		links { project_name }
	filter {}
	dependson { project_name }
end

function cp.add_project(modules)
	local config_content = [[
// Core Perks (https://github.com/smogpill/core_perks)
// SPDX-FileCopyrightText: 2025 Jounayd ID SALAH
// SPDX-License-Identifier: MIT
// 
// File generated by core_perks.lua
#pragma once

]]

	for _, module in ipairs(modules) do
		module.add_dependency()
		config_content = config_content .. "#define CP_".. module.define_suffix .. "\n"
	end

	local core_perks_path = path.join(cp.extern_path, "core_perks/core_perks")

	-- Write generated/config.h file
	local config_path = path.join(core_perks_path, "generated/config.h")
	local file = io.open(config_path, "w")
	if not file then
		cp.error("Failed to open "..config_path.." for write")
		return
	end
	file:write(config_content)
	file:close()

	include(core_perks_path)
end
